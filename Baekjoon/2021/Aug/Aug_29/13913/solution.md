## 문제

https://www.acmicpc.net/problem/13913

- `0 <= N,K <= 100,000` 인 `N,K`가 주어진다.
- `N` 은 `+1, -1, *2` 만큼 이동 가능하며 `K` 가 될 때까지 이동한다.
- 위의 규칙대로 이동하며 `N`에서 `K` 까지 이동 할 때의 최소 경로를 구한다.

## 풀이 아이디어

### 핵심 아이디어

- BFS를 이용한 완전탐색
  - `collections` 라이브러리의 `deque` 를 사용한다.
  - `deque`에 현재 위치 기준 `+1, -1, *2` 값과 깊이를 넣어 완전탐색한다.
- 지나온 경로 추적
  - `100,001`크기의 배열을 사용하여 `n` 위치에서 `n+1,n-1,2*n`위치로 이동할 때,  `n+1,n-1,2*n` 인덱스의 값을 `n`으로 하여 이 인덱스로 이동하기 위해 `n`을 거쳐 갔다는것을 표시한다.

### 풀이 아이디어

- BFS를 위한 `deque` 변수 `bfs` 를 만들어 시작위치 `N`과 시작깊이 `0`을 넣어 시작한다.
  - `bfs = [위치, 깊이]` , `check[idx] : idx로 가기위해 지나온 값`
  - `bfs` 안에 값이 없을 때까지 `while`반복한다.
  - `bfs`의 위치 값이 `K`가 된다면 반복을 종료한다.
    - `bfs`의 깊이 값을 출력한다.
    - `check[idx]`  의 값을 `answer` 에 넣는다.
      - `idx`의 값이 `N`이 되기 전까지 이동한다.
      - 다음 `idx`는 `check[idx]` 의 값
    - `answer`는 역순으로 저장됬기 때문에 출력은 역순으로 한다,
  - `bfs`의 위치값이 `K`가 아닐때
    - `cur-1`, `cur+1`, `cur*2`가 범위 안 이라면 큐에 추가한다.
    - `check[cur-1] = cur` 하여 해당 위치로 가기위해 거쳐왔던 위치를 저장한다.

